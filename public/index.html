<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Stressor</title>
		<style>
			canvas {
				margin-top: 20px;
			}
			body {
				max-width: 778px;
			}
		</style>

		<script type="text/javascript" src="react"></script>
		<script type="text/javascript" src="chartjs"></script>
		<script type="text/javascript" src="react-chartjs"></script>
		<script type="text/javascript" src="underscore"></script>
		<script type="text/javascript" src="zepto"></script>
		<script type="text/javascript" src="socketio"></script>
	</head>
	<body>
		<div id="scenario"></div>
		<div id="charts"></div>
	</body>

	<script>

	// Charts settings
	Chart.defaults.global.responsive = true;
	Chart.defaults.global.scaleLineWidth = 2;

	// Create socket connection
	var socket = io();

	var msgScenarioName = '';

	// Object to show for chart
	var msgResponse = {
		labels: [],
		datasets: []
	};

	var msgAvailable = {
		labels: [],
		datasets: [
			{
				label: "Available",
				fillColor: "rgba(220,220,220,0.5)",
				strokeColor: "rgba(220,220,220,0.8)",
				highlightFill: "rgba(220,220,220,0.75)",
				highlightStroke: "rgba(220,220,220,1)",
				data: []
			},
			{
				label: "Busy",
				fillColor: "rgba(151,187,205,0.5)",
				strokeColor: "rgba(151,187,205,0.8)",
				highlightFill: "rgba(151,187,205,0.75)",
				highlightStroke: "rgba(151,187,205,1)",
				data: []
			}
		]
	};

	var workerCounter = 0;
	var firstTime = 1;
	var responseIterator = 0;

	socket.on('statistics collected', function(msg) {

		msgScenarioName = msg.name;

		// Update response data
		for (var key in msg.data) {
			if (msg.data.hasOwnProperty(key)) {
				msgResponse.datasets.push({
					label: 'Worker #' + key,
					fillColor: "rgba(220,220,220,0.2)",
					strokeColor: "rgba(220,220,220,1)",
					pointColor: "rgba(220,220,220,1)",
					pointStrokeColor: "#fff",
					pointHighlightFill: "#fff",
					pointHighlightStroke: "rgba(220,220,220,1)",
					data: []
				});

				for (var response in msg.data[key]) {
					if (msg.data[key].hasOwnProperty(response)) {
						if(firstTime > 0) {
							msgResponse.labels.push('Cycle #' + firstTime);
							firstTime++;
						}
						var responseTime = msg.data[key][response].endTime
							- msg.data[key][response].startTime;
						if (responseTime < 0) {
							responseTime = 0;
						}
						msgResponse.datasets[responseIterator].data.push(responseTime);
					}
				}
				responseIterator++;
				firstTime = 0;
			}
		}

		// Update availability data
		msgAvailable.labels.push('Worker #' + (workerCounter + 1));
		msgAvailable.datasets[0].data[workerCounter] = msg.incrMap.AVAILABLE;
		msgAvailable.datasets[1].data[workerCounter] = msg.incrMap.BUSY;
		workerCounter++;
	});

	socket.on('finished collection', function() {
		console.log('Finished data collection');
		
		// Delete previously rendered chart
		var element = document.getElementById("charts");
		while (element.firstChild) {
			element.removeChild(element.firstChild);
		}

		showScenarioName(msgScenarioName);

		showChart('Bar', 'Server Availability', {
			data: availabilityData,
			msg: msgAvailable,
		});

		showChart('Line', 'Response Time', {
			data: responseData,
			msg: msgResponse,
		});

		// Update worker worker
		workerCounter = 0;

		// Update firstTime switcher
		firstTime = 1;

		// Updat response iterator
		responseIterator = 0;

		// Update availability data
		msgAvailable.labels = [];
		msgAvailable.datasets[0].data = [];
		msgAvailable.datasets[1].data = [];


		// Update response data
		msgResponse.labels = [];
		msgResponse.datasets = [];
	});

	function availabilityData(msgAvaialble) {
		return msgAvailable;
	}

	function responseData(msgResponse) {
		return msgResponse;
	}

	var ChartContainer = React.createFactory(React.createClass({

		getInitialState: function() {
			return {
				data: this.props.props.data(this.props.props.msg)
			};
		},

		render: function() {
			var props = this.props.props;
			var factory = this.props.factory;

			var _props = _.defaults({
				data: this.state.data
			}, props);

			var component = new factory(_props);

			return React.createElement('div', {}, component);
		},

		restart: function() {
			this.setState({data: this.props.props.data(this.props.props.msg)});
		}
	}));

	function showScenarioName(name) {
		var container = document.getElementById('scenario');
		while (container.firstChild) {
    	container.removeChild(container.firstChild);
		}

		var container = $('#scenario');
		var root = document.createElement('div');
		container.append(root);

		var title = $('<h1>' + name + '</h1>');
		root.appendChild(title[0]);
	}


	function showChart(type, name, props) {
		var factory = React.createFactory(Chart.React[type]);
		var component = new ChartContainer({props: props, factory: factory});

		var container = $('#charts');
		var root = document.createElement('div');
		container.append(root);

		var title = $('<h2>' + name + '</h2>');
		root.appendChild(title[0]);

		var chartContainer = document.createElement('div');
		root.appendChild(chartContainer);
		React.render(component, chartContainer);
	}


	/* $(document).ready( function() {

		showScenarioName(msgScenarioName);

		showChart('Bar', 'Server Availability', {
			data: availabilityData,
			msg: msgAvailable,
		});

		showChart('Line', 'Response Time', {
			data: responseData,
			msg: 70,
		});

	}); */



	</script>
</html>
		